import struct
import sys
from os import getenv
from pathlib import Path

from tools import align_byte_size, get_alignment


def resource_path(relPath: str = "") -> Path:
    """
    Get absolute path to resource, works for dev and for cx_freeze
    """
    import sys

    if hasattr(sys, "_MEIPASS"):
        return Path(getattr(sys, "_MEIPASS", Path(__file__).parent)) / relPath
    else:
        if getattr(sys, "frozen", False):
            # The application is frozen
            base_path = Path(sys.executable).parent
        else:
            base_path = Path(__file__).parent

        return base_path / relPath


def get_program_folder(folder: str = "") -> Path:
    """Get path to appdata"""
    if sys.platform == "win32":
        datapath = Path(getenv("APPDATA")) / folder
    elif sys.platform == "darwin":
        if folder:
            folder = "." + folder
        datapath = Path("~/Library/Application Support").expanduser() / folder
    elif "linux" in sys.platform:
        if folder:
            folder = "." + folder
        datapath = Path.home() / folder
    else:
        raise NotImplementedError(f"{sys.platform} OS is unsupported")
    return datapath


def read_sbyte(f):
    return struct.unpack("b", f.read(1))[0]


def write_sbyte(f, val):
    f.write(struct.pack("b", val))


def read_sint16(f):
    return struct.unpack(">h", f.read(2))[0]


def write_sint16(f, val):
    f.write(struct.pack(">h", val))


def read_sint32(f):
    return struct.unpack(">i", f.read(4))[0]


def write_sint32(f, val):
    f.write(struct.pack(">i", val))


def read_ubyte(f):
    return struct.unpack("B", f.read(1))[0]


def write_ubyte(f, val):
    f.write(struct.pack("B", val))


def read_uint16(f):
    return struct.unpack(">H", f.read(2))[0]


def write_uint16(f, val):
    f.write(struct.pack(">H", val))


def read_uint32(f):
    return struct.unpack(">I", f.read(4))[0]


def write_uint32(f, val):
    f.write(struct.pack(">I", val))


def read_float(f):
    return struct.unpack(">f", f.read(4))[0]


def write_float(f, val):
    f.write(struct.pack(">f", val))


def read_double(f):
    return struct.unpack(">d", f.read(4))[0]


def write_double(f, val):
    f.write(struct.pack(">d", val))


def read_bool(f, vSize=1):
    return struct.unpack("B", f.read(vSize))[0] > 0


def write_bool(f, val, vSize=1):
    (
        f.write(b"\x00" * (vSize - 1) + b"\x01")
        if val is True
        else f.write(b"\x00" * vSize)
    )
